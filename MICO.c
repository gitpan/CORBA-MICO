/*
 * This file was generated automatically by xsubpp version 1.9506 from the 
 * contents of MICO.xs. Do not edit this file, edit MICO.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "MICO.xs"
/* -*- mode: C++; c-file-style: "bsd" -*- */

#include "pmico.h"
#include "exttypes.h"
#include <mico/ir.h>

/* FIXME: Boot check screws up with egcs... */
#undef XS_VERSION_BOOTCHECK
#define XS_VERSION_BOOTCHECK

typedef CORBA::Any *        CORBA__Any;
typedef CORBA::BOA_ptr      CORBA__BOA;
typedef CORBA::Object_ptr   CORBA__Object;
typedef CORBA::ORB_ptr      CORBA__ORB;
typedef CORBA::TypeCode_ptr CORBA__TypeCode;
typedef CORBA::Dispatcher * CORBA__Dispatcher;
typedef CORBA::LongLong     CORBA__LongLong;
typedef CORBA::ULongLong    CORBA__ULongLong;
typedef CORBA::LongDouble   CORBA__LongDouble;
typedef PMicoRestorer *     CORBA__BOAObjectRestorer;

#ifdef HAVE_GTK

#undef list
#include "gtkmico.h"

typedef GtkDispatcher *CORBA__MICO__GtkDispatcher;

void *get_c_func (char *name)
{
    SV *result;
    int count;
    
    dSP;

    PUSHMARK(sp);
    XPUSHs (sv_2mortal (newSVpv (name, 0)));
    PUTBACK;
    
    count = perl_call_pv ("DynaLoader::dl_find_symbol_anywhere", 
			  G_SCALAR | G_EVAL);
    SPAGAIN;

    if (count != 1)
	croak ("Gtk::get_c_func returned %d items", count);

    result = POPs;

    if (!SvOK (result))
	croak ("Could not get C function for %s", name);

    PUTBACK;

    return (void *)SvIV(result);
}
#endif /* HAVE_GTK */

XS(XS_CORBA__MICO_load_interface)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::MICO::load_interface(interface)");
    {
	CORBA__Object	interface = pmico_sv_to_obj (ST(0));
	char *	RETVAL;
#line 64 "MICO.xs"
    {
	CORBA::InterfaceDef_var iface = CORBA::InterfaceDef::_narrow (interface);
	PMicoIfaceInfo *info = pmico_load_interface (iface, NULL, NULL);
	RETVAL = info ? (char *)info->pkg.c_str() : NULL;
    }
#line 82 "MICO.c"
	ST(0) = sv_newmortal();
	sv_setpv((SV*)ST(0), RETVAL);
    }
    XSRETURN(1);
}

XS(XS_CORBA_ORB_init)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::ORB_init(id)");
    {
	char *	id = (char *)SvPV(ST(0),na);
	CORBA__ORB	RETVAL;
#line 78 "MICO.xs"
    {
	int argc, i;
	char ** argv;
	AV * ARGV;
	SV * ARGV0;

	RETVAL = CORBA::ORB_instance (id, FALSE);
	if (!RETVAL) {

	    ARGV = perl_get_av("ARGV", FALSE);
	    ARGV0 = perl_get_sv("0", FALSE);

	    argc = av_len(ARGV)+2;
	    argv = (char **)malloc (sizeof(char *)*argc);
	    argv[0] = SvPV (ARGV0, na);
	    for (i=0;i<=av_len(ARGV);i++)
		argv[i+1] = SvPV(*av_fetch(ARGV, i, 0), na);

	    RETVAL = CORBA::ORB_init (argc, argv, id);

	    av_clear (ARGV);

	    for (i=1;i<argc;i++)
		av_store (ARGV, i-1, newSVpv(argv[i],0));

	    if (argv)
		free (argv);
	}
    }
#line 127 "MICO.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "CORBA::ORB", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_CORBA__Any_new)
{
    dXSARGS;
    if (items != 3)
	croak("Usage: CORBA::Any::new(pkg, type, value)");
    {
	CORBA__TypeCode	type;
	SV *	value = ST(2);
	CORBA__Any	RETVAL;

	if (sv_derived_from(ST(1), "CORBA::TypeCode")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    type = (CORBA__TypeCode) tmp;
	}
	else
	    croak("type is not of type CORBA::TypeCode");
#line 117 "MICO.xs"
    RETVAL = new CORBA::Any;
    RETVAL->type(type);
    if (!pmico_to_any (RETVAL, value)) {
        delete RETVAL;
	croak("Error constructing Any");
    }
#line 157 "MICO.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "CORBA::Any", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_CORBA__Any_value)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::Any::value(self)");
    {
	CORBA__Any	self;
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "CORBA::Any")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__Any) tmp;
	}
	else
	    croak("self is not of type CORBA::Any");
#line 130 "MICO.xs"
    RETVAL = pmico_from_any (self);
#line 181 "MICO.c"
	ST(0) = RETVAL;
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__Any_type)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::Any::type(self)");
    {
	CORBA__Any	self;
	CORBA__TypeCode	RETVAL;

	if (sv_derived_from(ST(0), "CORBA::Any")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__Any) tmp;
	}
	else
	    croak("self is not of type CORBA::Any");
#line 138 "MICO.xs"
    RETVAL = self->type ();
#line 205 "MICO.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "CORBA::TypeCode", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_CORBA__Any_DESTROY)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::Any::DESTROY(self)");
    {
	CORBA__Any	self;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__Any) tmp;
	}
	else
	    croak("self is not a reference");
#line 146 "MICO.xs"
    delete self;
#line 228 "MICO.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_CORBA__BOA_impl_is_ready)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: CORBA::BOA::impl_is_ready(self, impl)");
    {
	CORBA__BOA	self;
	CORBA__Object	impl = pmico_sv_to_obj (ST(1));

	if (sv_derived_from(ST(0), "CORBA::BOA")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__BOA) tmp;
	}
	else
	    croak("self is not of type CORBA::BOA");
#line 155 "MICO.xs"
    {
	CORBA::ImplementationDef_var i = CORBA::ImplementationDef::_narrow (impl);
	self->impl_is_ready (i);
    }
#line 253 "MICO.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_CORBA__BOA_deactivate_impl)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: CORBA::BOA::deactivate_impl(self, impl)");
    {
	CORBA__BOA	self;
	CORBA__Object	impl = pmico_sv_to_obj (ST(1));

	if (sv_derived_from(ST(0), "CORBA::BOA")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__BOA) tmp;
	}
	else
	    croak("self is not of type CORBA::BOA");
#line 165 "MICO.xs"
    {
	CORBA::ImplementationDef_var i = CORBA::ImplementationDef::_narrow (impl);
	self->deactivate_impl (i);
    }
#line 278 "MICO.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_CORBA__BOA_obj_is_ready)
{
    dXSARGS;
    if (items != 3)
	croak("Usage: CORBA::BOA::obj_is_ready(self, obj, impl)");
    {
	CORBA__BOA	self;
	CORBA__Object	obj = pmico_sv_to_obj (ST(1));
	CORBA__Object	impl = pmico_sv_to_obj (ST(2));

	if (sv_derived_from(ST(0), "CORBA::BOA")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__BOA) tmp;
	}
	else
	    croak("self is not of type CORBA::BOA");
#line 176 "MICO.xs"
    {
	CORBA::ImplementationDef_var i = CORBA::ImplementationDef::_narrow (impl);
	self->obj_is_ready (obj, i);
    }
#line 304 "MICO.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_CORBA__BOA_deactivate_obj)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: CORBA::BOA::deactivate_obj(self, obj)");
    {
	CORBA__BOA	self;
	CORBA__Object	obj = pmico_sv_to_obj (ST(1));

	if (sv_derived_from(ST(0), "CORBA::BOA")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__BOA) tmp;
	}
	else
	    croak("self is not of type CORBA::BOA");
#line 186 "MICO.xs"
    self->deactivate_obj (obj);
#line 326 "MICO.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_CORBA__BOA_dispose)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: CORBA::BOA::dispose(self, obj)");
    {
	CORBA__BOA	self;
	CORBA__Object	obj = pmico_sv_to_obj (ST(1));

	if (sv_derived_from(ST(0), "CORBA::BOA")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__BOA) tmp;
	}
	else
	    croak("self is not of type CORBA::BOA");
#line 193 "MICO.xs"
    self->dispose(obj);
#line 348 "MICO.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_CORBA__BOA_DESTROY)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::BOA::DESTROY(self)");
    {
	CORBA__BOA	self;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__BOA) tmp;
	}
	else
	    croak("self is not a reference");
#line 200 "MICO.xs"
    CORBA::release (self);
#line 369 "MICO.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_CORBA__ORB_BOA_init)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: CORBA::ORB::BOA_init(self, boa_id)");
    {
	CORBA__ORB	self;
	char *	boa_id = (char *)SvPV(ST(1),na);
	CORBA__BOA	RETVAL;

	if (sv_derived_from(ST(0), "CORBA::ORB")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__ORB) tmp;
	}
	else
	    croak("self is not of type CORBA::ORB");
#line 209 "MICO.xs"
    {
    int argc, i;
    char ** argv;
    AV * ARGV;
    SV * ARGV0;

    ARGV = perl_get_av("ARGV", FALSE);
    ARGV0 = perl_get_sv("0", FALSE);

    argc = av_len(ARGV)+2;
    argv = (char **)malloc (sizeof(char *)*argc);
    argv[0] = SvPV (ARGV0, na);
    for (i=0;i<=av_len(ARGV);i++)
	argv[i+1] = SvPV(*av_fetch(ARGV, i, 0), na);

    RETVAL = self->BOA_init (argc, argv, boa_id);

    av_clear (ARGV);

    for (i=1;i<argc;i++)
	av_store (ARGV, i-1, newSVpv(argv[i],0));

    if (argv)
	free (argv);
    }
#line 416 "MICO.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "CORBA::BOA", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_CORBA__ORB_dispatcher)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: CORBA::ORB::dispatcher(self, disp)");
    {
	CORBA__ORB	self;
	SV *	disp = ST(1);

	if (sv_derived_from(ST(0), "CORBA::ORB")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__ORB) tmp;
	}
	else
	    croak("self is not of type CORBA::ORB");
#line 242 "MICO.xs"
    {
	CORBA::Dispatcher *d;
	if (!SvROK (disp) || !sv_derived_from (disp, "CORBA::Dispatcher"))
	    croak ("Argument to CORBA::ORB::dispatcher is not a CORBA::Dispatcher");
	d = (CORBA::Dispatcher *)SvIV(SvRV(disp));
	if (!d)
	    croak ("Cannot use same CORBA::Dispatcher multiple times");

	self->dispatcher (d);
	sv_setiv (SvRV(disp), 0);		// ORB takes ownership 
    }
#line 450 "MICO.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_CORBA__ORB_object_to_string)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: CORBA::ORB::object_to_string(self, obj)");
    {
	CORBA__ORB	self;
	CORBA__Object	obj = pmico_sv_to_obj (ST(1));
	char *	RETVAL;

	if (sv_derived_from(ST(0), "CORBA::ORB")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__ORB) tmp;
	}
	else
	    croak("self is not of type CORBA::ORB");
#line 259 "MICO.xs"
    RETVAL = (char *)self->object_to_string (obj);
#line 473 "MICO.c"
	ST(0) = sv_newmortal();
	sv_setpv((SV*)ST(0), RETVAL);
    }
    XSRETURN(1);
}

XS(XS_CORBA__ORB_resolve_initial_references)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: CORBA::ORB::resolve_initial_references(self, id)");
    {
	CORBA__ORB	self;
	char *	id = (char *)SvPV(ST(1),na);
	CORBA__Object	RETVAL;

	if (sv_derived_from(ST(0), "CORBA::ORB")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__ORB) tmp;
	}
	else
	    croak("self is not of type CORBA::ORB");
#line 268 "MICO.xs"
    RETVAL = self->resolve_initial_references (id);
#line 498 "MICO.c"
	ST(0) = pmico_find_or_create (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__ORB_string_to_object)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: CORBA::ORB::string_to_object(self, str)");
    {
	CORBA__ORB	self;
	char *	str = (char *)SvPV(ST(1),na);
	CORBA__Object	RETVAL;

	if (sv_derived_from(ST(0), "CORBA::ORB")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__ORB) tmp;
	}
	else
	    croak("self is not of type CORBA::ORB");
#line 277 "MICO.xs"
    RETVAL = self->string_to_object (str);
#line 523 "MICO.c"
	ST(0) = pmico_find_or_create (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__ORB_bind)
{
    dXSARGS;
    if (items < 2 || items > 4)
	croak("Usage: CORBA::ORB::bind(self, repoid, object_tag = 0, addr = 0)");
    {
	CORBA__ORB	self;
	char *	repoid = (char *)SvPV(ST(1),na);
	SV *	object_tag;
	char *	addr;
	CORBA__Object	RETVAL;

	if (sv_derived_from(ST(0), "CORBA::ORB")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__ORB) tmp;
	}
	else
	    croak("self is not of type CORBA::ORB");

	if (items < 3)
	    object_tag = 0;
	else {
	    object_tag = ST(2);
	}

	if (items < 4)
	    addr = 0;
	else {
	    addr = (char *)SvPV(ST(3),na);
	}
#line 288 "MICO.xs"
    {
	int len, i;
	char *p;

	CORBA::ORB::ObjectTag_var tag = new CORBA::ORB::ObjectTag;

	if (object_tag && SvOK(object_tag)) {
	    p = SvPV (object_tag, na);
	    for (i = 0; i < len; i++)
		(*tag)[i] = p[i];
	}

	RETVAL = self->bind (repoid, *tag, addr);
    }
#line 575 "MICO.c"
	ST(0) = pmico_find_or_create (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__ORB_preload)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: CORBA::ORB::preload(self, id)");
    {
	CORBA__ORB	self;
	char *	id = (char *)SvPV(ST(1),na);
	int	RETVAL;

	if (sv_derived_from(ST(0), "CORBA::ORB")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__ORB) tmp;
	}
	else
	    croak("self is not of type CORBA::ORB");
#line 310 "MICO.xs"
    pmico_load_interface (NULL, self, id);
#line 600 "MICO.c"
	ST(0) = sv_newmortal();
	sv_setiv(ST(0), (IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_CORBA__ORB_DESTROY)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::ORB::DESTROY(self)");
    {
	CORBA__ORB	self;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__ORB) tmp;
	}
	else
	    croak("self is not a reference");
#line 318 "MICO.xs"
    CORBA::release (self);
#line 623 "MICO.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_CORBA__ORB_run)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::ORB::run(self)");
    {
	CORBA__ORB	self;

	if (sv_derived_from(ST(0), "CORBA::ORB")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__ORB) tmp;
	}
	else
	    croak("self is not of type CORBA::ORB");
#line 324 "MICO.xs"
    self->run();
#line 644 "MICO.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_CORBA__ORB_shutdown)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: CORBA::ORB::shutdown(self, wait_for_completion)");
    {
	CORBA__ORB	self;
	SV *	wait_for_completion = ST(1);

	if (sv_derived_from(ST(0), "CORBA::ORB")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__ORB) tmp;
	}
	else
	    croak("self is not of type CORBA::ORB");
#line 331 "MICO.xs"
    self->shutdown (SvTRUE (wait_for_completion));
#line 666 "MICO.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_CORBA__ORB_perform_work)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::ORB::perform_work(self)");
    {
	CORBA__ORB	self;

	if (sv_derived_from(ST(0), "CORBA::ORB")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__ORB) tmp;
	}
	else
	    croak("self is not of type CORBA::ORB");
#line 337 "MICO.xs"
    self->perform_work ();
#line 687 "MICO.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_CORBA__ORB_work_pending)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::ORB::work_pending(self)");
    {
	CORBA__ORB	self;
	int	RETVAL;

	if (sv_derived_from(ST(0), "CORBA::ORB")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__ORB) tmp;
	}
	else
	    croak("self is not of type CORBA::ORB");
#line 343 "MICO.xs"
    RETVAL = self->work_pending ();
#line 709 "MICO.c"
	ST(0) = sv_newmortal();
	sv_setiv(ST(0), (IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_CORBA__Object__get_interface)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::Object::_get_interface(self)");
    {
	CORBA__Object	self = pmico_sv_to_obj (ST(0));
	CORBA__Object	RETVAL;
#line 353 "MICO.xs"
    RETVAL = self->_get_interface();
#line 726 "MICO.c"
	ST(0) = pmico_find_or_create (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__Object__get_implementation)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::Object::_get_implementation(self)");
    {
	CORBA__Object	self = pmico_sv_to_obj (ST(0));
	CORBA__Object	RETVAL;
#line 361 "MICO.xs"
    RETVAL = self->_get_implementation();
#line 743 "MICO.c"
	ST(0) = pmico_find_or_create (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__Object__repoid)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::Object::_repoid(self)");
    {
	CORBA__Object	self = pmico_sv_to_obj (ST(0));
	char *	RETVAL;
#line 369 "MICO.xs"
    RETVAL = (char *)self->_repoid ();
#line 760 "MICO.c"
	ST(0) = sv_newmortal();
	sv_setpv((SV*)ST(0), RETVAL);
    }
    XSRETURN(1);
}

XS(XS_CORBA__Object__ident)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::Object::_ident(self)");
    {
	CORBA__Object	self = pmico_sv_to_obj (ST(0));
	char *	RETVAL;
#line 377 "MICO.xs"
    RETVAL = (char *)self->_ident ();
#line 777 "MICO.c"
	ST(0) = sv_newmortal();
	sv_setpv((SV*)ST(0), RETVAL);
    }
    XSRETURN(1);
}

XS(XS_CORBA__Object__set_repoid)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: CORBA::Object::_set_repoid(self, repoid)");
    {
	SV *	self = ST(0);
	char *	repoid = (char *)SvPV(ST(1),na);
#line 386 "MICO.xs"
    {
	PMicoInstVars *iv = pmico_instvars_get (self);
	if (!iv) {
	    iv = pmico_instvars_add (self);
	}

	iv->repoid = new string (repoid);
    }
#line 801 "MICO.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_CORBA__Object__boa)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::Object::_boa(self)");
    {
	SV *	self = ST(0);
	CORBA__BOA	RETVAL;
#line 399 "MICO.xs"
    {
	PMicoInstVars *iv = pmico_instvars_get (self);
	if (!iv || !iv->obj) {
	    iv = pmico_init_obj (self, NULL, NULL, NULL, NULL, NULL);
	} else {
	    if (!iv->trueobj)
		croak ("CORBA::Object::_boa: object must be true");
	}

	RETVAL = iv->trueobj->_boa();
    }
#line 826 "MICO.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "CORBA::BOA", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_CORBA__Object__self)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::Object::_self(self)");
    {
	CORBA__Object	self = pmico_sv_to_obj (ST(0));
	CORBA__Object	RETVAL;
#line 417 "MICO.xs"
    RETVAL = self;
#line 843 "MICO.c"
	ST(0) = pmico_find_or_create (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__Object__restore)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: CORBA::Object::_restore(self, object)");
    {
	SV *	self = ST(0);
	CORBA__Object	object = pmico_sv_to_obj (ST(1));
#line 426 "MICO.xs"
    {
	PMicoInstVars *iv = pmico_instvars_get (self);
	if (iv)
	    croak ("CORBA::Object::_restore called on previously initialized object");
	else
	    iv = pmico_init_obj (self, object, NULL, NULL, NULL, NULL);
    }
#line 866 "MICO.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_CORBA__TypeCode_new)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: CORBA::TypeCode::new(pkg, id)");
    {
	char *	id = (char *)SvPV(ST(1),na);
	SV *	RETVAL;
#line 440 "MICO.xs"
    RETVAL = pmico_lookup_typecode (id);
    if (RETVAL == NULL)
        croak("Cannot find typecode for '%s'", id);
#line 883 "MICO.c"
	ST(0) = RETVAL;
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__TypeCode_DESTROY)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::TypeCode::DESTROY(self)");
    {
	CORBA__TypeCode	self;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__TypeCode) tmp;
	}
	else
	    croak("self is not a reference");
#line 450 "MICO.xs"
    CORBA::release (self);
#line 906 "MICO.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_CORBA__BOAObjectRestorer_new)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::BOAObjectRestorer::new(Class)");
    {
	CORBA__BOAObjectRestorer	RETVAL;
#line 459 "MICO.xs"
    RETVAL = new PMicoRestorer;
#line 920 "MICO.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "CORBA::BOAObjectRestorer", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_CORBA__BOAObjectRestorer_add_binders)
{
    dXSARGS;
    if (items < 1)
	croak("Usage: CORBA::BOAObjectRestorer::add_binders(self, ...)");
    {
	CORBA__BOAObjectRestorer	self;

	if (sv_derived_from(ST(0), "CORBA::BOAObjectRestorer")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__BOAObjectRestorer) tmp;
	}
	else
	    croak("self is not of type CORBA::BOAObjectRestorer");
#line 467 "MICO.xs"
    {
	int i;

	if (items%2 != 1)
	    croak("Usage: restorer->add_binder ([REPOID => CALLBACK], ...)");
	for (i = 1 ; i < items ; i += 2)
	    self->add_binder (SvPV (ST(i), na), ST(i+1));
    }
#line 950 "MICO.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_CORBA__BOAObjectRestorer_add_restorers)
{
    dXSARGS;
    if (items < 1)
	croak("Usage: CORBA::BOAObjectRestorer::add_restorers(self, ...)");
    {
	CORBA__BOAObjectRestorer	self;

	if (sv_derived_from(ST(0), "CORBA::BOAObjectRestorer")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__BOAObjectRestorer) tmp;
	}
	else
	    croak("self is not of type CORBA::BOAObjectRestorer");
#line 480 "MICO.xs"
    {
	int i;

	if (items%2 != 1)
	    croak("Usage: restorer->add_restorer ([REPOID => CALLBACK], ...)");
	for (i = 1 ; i < items ; i += 2)
	    self->add_restorer (SvPV (ST(i), na), ST(i+1));
    }
#line 978 "MICO.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_CORBA__LongLong_new)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: CORBA::LongLong::new(Class, str)");
    {
	char *	str = (char *)SvPV(ST(1),na);
	CORBA__LongLong	RETVAL;
#line 495 "MICO.xs"
    RETVAL = longlong_from_string (str);
#line 993 "MICO.c"
	ST(0) = ll_from_longlong (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__LongLong_stringify)
{
    dXSARGS;
    if (items < 1 || items > 3)
	croak("Usage: CORBA::LongLong::stringify(self, other=0, reverse=&sv_undef)");
    {
	CORBA__LongLong	self;
	SV *	RETVAL;

        self = SvLLV (ST(0));
#line 503 "MICO.xs"
    {
	char *result = longlong_to_string (self);
        RETVAL = newSVpv (result, 0);
	Safefree (result);
    }
#line 1016 "MICO.c"
	ST(0) = RETVAL;
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__LongLong_add)
{
    dXSARGS;
    if (items < 2 || items > 3)
	croak("Usage: CORBA::LongLong::add(self, other, reverse=&sv_undef)");
    {
	CORBA__LongLong	self;
	CORBA__LongLong	other;
	CORBA__LongLong	RETVAL;

        self = SvLLV (ST(0));

        other = SvLLV (ST(1));
#line 516 "MICO.xs"
    RETVAL = self+other;
#line 1038 "MICO.c"
	ST(0) = ll_from_longlong (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__LongLong_subtract)
{
    dXSARGS;
    if (items < 2 || items > 3)
	croak("Usage: CORBA::LongLong::subtract(self, other, reverse=&sv_undef)");
    {
	CORBA__LongLong	self;
	CORBA__LongLong	other;
	SV *	reverse;
	CORBA__LongLong	RETVAL;

        self = SvLLV (ST(0));

        other = SvLLV (ST(1));

	if (items < 3)
	    reverse = &sv_undef;
	else {
	    reverse = ST(2);
	}
#line 526 "MICO.xs"
    if (SvTRUE (reverse))
        RETVAL = other - self;
    else
        RETVAL = self - other;
#line 1070 "MICO.c"
	ST(0) = ll_from_longlong (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__LongLong_div)
{
    dXSARGS;
    if (items < 2 || items > 3)
	croak("Usage: CORBA::LongLong::div(self, other, reverse=&sv_undef)");
    {
	CORBA__LongLong	self;
	CORBA__LongLong	other;
	SV *	reverse;
	CORBA__LongLong	RETVAL;

        self = SvLLV (ST(0));

        other = SvLLV (ST(1));

	if (items < 3)
	    reverse = &sv_undef;
	else {
	    reverse = ST(2);
	}
#line 539 "MICO.xs"
    if (SvTRUE (reverse))
        RETVAL = other / self;
    else
        RETVAL = self / other;
#line 1102 "MICO.c"
	ST(0) = ll_from_longlong (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__LongLong_mul)
{
    dXSARGS;
    if (items < 2 || items > 3)
	croak("Usage: CORBA::LongLong::mul(self, other, reverse=&sv_undef)");
    {
	CORBA__LongLong	self;
	CORBA__LongLong	other;
	CORBA__LongLong	RETVAL;

        self = SvLLV (ST(0));

        other = SvLLV (ST(1));
#line 551 "MICO.xs"
    RETVAL = self*other;
#line 1124 "MICO.c"
	ST(0) = ll_from_longlong (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__LongLong_mod)
{
    dXSARGS;
    if (items < 2 || items > 3)
	croak("Usage: CORBA::LongLong::mod(self, other, reverse=&sv_undef)");
    {
	CORBA__LongLong	self;
	CORBA__LongLong	other;
	SV *	reverse;
	CORBA__LongLong	RETVAL;

        self = SvLLV (ST(0));

        other = SvLLV (ST(1));

	if (items < 3)
	    reverse = &sv_undef;
	else {
	    reverse = ST(2);
	}
#line 561 "MICO.xs"
    if (SvTRUE (reverse))
        RETVAL = other % self;
    else
        RETVAL = self % other;
#line 1156 "MICO.c"
	ST(0) = ll_from_longlong (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__LongLong_neg)
{
    dXSARGS;
    if (items < 1 || items > 3)
	croak("Usage: CORBA::LongLong::neg(self, other=0, reverse=&sv_undef)");
    {
	CORBA__LongLong	self;
	CORBA__LongLong	RETVAL;

        self = SvLLV (ST(0));
#line 572 "MICO.xs"
    RETVAL = -self;
#line 1175 "MICO.c"
	ST(0) = ll_from_longlong (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__LongLong_abs)
{
    dXSARGS;
    if (items < 1 || items > 3)
	croak("Usage: CORBA::LongLong::abs(self, other=0, reverse=&sv_undef)");
    {
	CORBA__LongLong	self;
	CORBA__LongLong	RETVAL;

        self = SvLLV (ST(0));
#line 580 "MICO.xs"
    RETVAL = (self > 0) ? self : -self;
#line 1194 "MICO.c"
	ST(0) = ll_from_longlong (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__LongLong_cmp)
{
    dXSARGS;
    if (items < 2 || items > 3)
	croak("Usage: CORBA::LongLong::cmp(self, other, reverse=&sv_undef)");
    {
	CORBA__LongLong	self;
	CORBA__LongLong	other;
	SV *	reverse;
	int	RETVAL;

        self = SvLLV (ST(0));

        other = SvLLV (ST(1));

	if (items < 3)
	    reverse = &sv_undef;
	else {
	    reverse = ST(2);
	}
#line 590 "MICO.xs"
    if (SvTRUE (reverse))
      RETVAL = (self == other) ? 0 : ((self > other) ? 1 : -1);
    else
      RETVAL = (other == self) ? 0 : ((other > self) ? 1 : -1);
#line 1226 "MICO.c"
	ST(0) = sv_newmortal();
	sv_setiv(ST(0), (IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_CORBA__ULongLong_new)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: CORBA::ULongLong::new(Class, str)");
    {
	char *	str = (char *)SvPV(ST(1),na);
	CORBA__ULongLong	RETVAL;
#line 603 "MICO.xs"
    RETVAL = ulonglong_from_string (str);
#line 1243 "MICO.c"
	ST(0) = ull_from_ulonglong (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__ULongLong_stringify)
{
    dXSARGS;
    if (items < 1 || items > 3)
	croak("Usage: CORBA::ULongLong::stringify(self, other=0, reverse=&sv_undef)");
    {
	CORBA__ULongLong	self;
	SV *	RETVAL;

        self = SvULLV (ST(0));
#line 611 "MICO.xs"
    {
	char *result = ulonglong_to_string (self);
        RETVAL = newSVpv (result, 0);
	Safefree (result);
    }
#line 1266 "MICO.c"
	ST(0) = RETVAL;
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__ULongLong_add)
{
    dXSARGS;
    if (items < 2 || items > 3)
	croak("Usage: CORBA::ULongLong::add(self, other, reverse=&sv_undef)");
    {
	CORBA__ULongLong	self;
	CORBA__ULongLong	other;
	CORBA__ULongLong	RETVAL;

        self = SvULLV (ST(0));

        other = SvULLV (ST(1));
#line 624 "MICO.xs"
    RETVAL = self+other;
#line 1288 "MICO.c"
	ST(0) = ull_from_ulonglong (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__ULongLong_subtract)
{
    dXSARGS;
    if (items < 2 || items > 3)
	croak("Usage: CORBA::ULongLong::subtract(self, other, reverse=&sv_undef)");
    {
	CORBA__ULongLong	self;
	CORBA__ULongLong	other;
	SV *	reverse;
	CORBA__ULongLong	RETVAL;

        self = SvULLV (ST(0));

        other = SvULLV (ST(1));

	if (items < 3)
	    reverse = &sv_undef;
	else {
	    reverse = ST(2);
	}
#line 634 "MICO.xs"
    if (SvTRUE (reverse))
        RETVAL = other - self;
    else
        RETVAL = self - other;
#line 1320 "MICO.c"
	ST(0) = ull_from_ulonglong (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__ULongLong_div)
{
    dXSARGS;
    if (items < 2 || items > 3)
	croak("Usage: CORBA::ULongLong::div(self, other, reverse=&sv_undef)");
    {
	CORBA__ULongLong	self;
	CORBA__ULongLong	other;
	SV *	reverse;
	CORBA__ULongLong	RETVAL;

        self = SvULLV (ST(0));

        other = SvULLV (ST(1));

	if (items < 3)
	    reverse = &sv_undef;
	else {
	    reverse = ST(2);
	}
#line 647 "MICO.xs"
    if (SvTRUE (reverse))
        RETVAL = other / self;
    else
        RETVAL = self / other;
#line 1352 "MICO.c"
	ST(0) = ull_from_ulonglong (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__ULongLong_mul)
{
    dXSARGS;
    if (items < 2 || items > 3)
	croak("Usage: CORBA::ULongLong::mul(self, other, reverse=&sv_undef)");
    {
	CORBA__ULongLong	self;
	CORBA__ULongLong	other;
	CORBA__ULongLong	RETVAL;

        self = SvULLV (ST(0));

        other = SvULLV (ST(1));
#line 659 "MICO.xs"
    RETVAL = self*other;
#line 1374 "MICO.c"
	ST(0) = ull_from_ulonglong (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__ULongLong_mod)
{
    dXSARGS;
    if (items < 2 || items > 3)
	croak("Usage: CORBA::ULongLong::mod(self, other, reverse=&sv_undef)");
    {
	CORBA__ULongLong	self;
	CORBA__ULongLong	other;
	SV *	reverse;
	CORBA__ULongLong	RETVAL;

        self = SvULLV (ST(0));

        other = SvULLV (ST(1));

	if (items < 3)
	    reverse = &sv_undef;
	else {
	    reverse = ST(2);
	}
#line 669 "MICO.xs"
    if (SvTRUE (reverse))
        RETVAL = other % self;
    else
        RETVAL = self % other;
#line 1406 "MICO.c"
	ST(0) = ull_from_ulonglong (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__ULongLong_cmp)
{
    dXSARGS;
    if (items < 2 || items > 3)
	croak("Usage: CORBA::ULongLong::cmp(self, other, reverse=&sv_undef)");
    {
	CORBA__ULongLong	self;
	CORBA__ULongLong	other;
	SV *	reverse;
	int	RETVAL;

        self = SvULLV (ST(0));

        other = SvULLV (ST(1));

	if (items < 3)
	    reverse = &sv_undef;
	else {
	    reverse = ST(2);
	}
#line 682 "MICO.xs"
    if (SvTRUE (reverse))
      RETVAL = (self == other) ? 0 : ((self > other) ? 1 : -1);
    else
      RETVAL = (other == self) ? 0 : ((other > self) ? 1 : -1);
#line 1438 "MICO.c"
	ST(0) = sv_newmortal();
	sv_setiv(ST(0), (IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_CORBA__LongDouble_new)
{
    dXSARGS;
    if (items != 2)
	croak("Usage: CORBA::LongDouble::new(Class, str)");
    {
	char *	str = (char *)SvPV(ST(1),na);
	CORBA__LongDouble	RETVAL;
#line 695 "MICO.xs"
    RETVAL = longdouble_from_string (str);
#line 1455 "MICO.c"
	ST(0) = ld_from_longdouble (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__LongDouble_stringify)
{
    dXSARGS;
    if (items < 1 || items > 3)
	croak("Usage: CORBA::LongDouble::stringify(self, other=0, reverse=&sv_undef)");
    {
	CORBA__LongDouble	self;
	SV *	RETVAL;

        self = SvLDV (ST(0));
#line 703 "MICO.xs"
    {
	char *result = longdouble_to_string (self);
        RETVAL = newSVpv (result, 0);
	Safefree (result);
    }
#line 1478 "MICO.c"
	ST(0) = RETVAL;
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__LongDouble_add)
{
    dXSARGS;
    if (items < 2 || items > 3)
	croak("Usage: CORBA::LongDouble::add(self, other, reverse=&sv_undef)");
    {
	CORBA__LongDouble	self;
	CORBA__LongDouble	other;
	CORBA__LongDouble	RETVAL;

        self = SvLDV (ST(0));

        other = SvLDV (ST(1));
#line 716 "MICO.xs"
    RETVAL = self+other;
#line 1500 "MICO.c"
	ST(0) = ld_from_longdouble (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__LongDouble_subtract)
{
    dXSARGS;
    if (items < 2 || items > 3)
	croak("Usage: CORBA::LongDouble::subtract(self, other, reverse=&sv_undef)");
    {
	CORBA__LongDouble	self;
	CORBA__LongDouble	other;
	SV *	reverse;
	CORBA__LongDouble	RETVAL;

        self = SvLDV (ST(0));

        other = SvLDV (ST(1));

	if (items < 3)
	    reverse = &sv_undef;
	else {
	    reverse = ST(2);
	}
#line 726 "MICO.xs"
    if (SvTRUE (reverse))
        RETVAL = other - self;
    else
        RETVAL = self - other;
#line 1532 "MICO.c"
	ST(0) = ld_from_longdouble (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__LongDouble_div)
{
    dXSARGS;
    if (items < 2 || items > 3)
	croak("Usage: CORBA::LongDouble::div(self, other, reverse=&sv_undef)");
    {
	CORBA__LongDouble	self;
	CORBA__LongDouble	other;
	SV *	reverse;
	CORBA__LongDouble	RETVAL;

        self = SvLDV (ST(0));

        other = SvLDV (ST(1));

	if (items < 3)
	    reverse = &sv_undef;
	else {
	    reverse = ST(2);
	}
#line 739 "MICO.xs"
    if (SvTRUE (reverse))
        RETVAL = other / self;
    else
        RETVAL = self / other;
#line 1564 "MICO.c"
	ST(0) = ld_from_longdouble (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__LongDouble_mul)
{
    dXSARGS;
    if (items < 2 || items > 3)
	croak("Usage: CORBA::LongDouble::mul(self, other, reverse=&sv_undef)");
    {
	CORBA__LongDouble	self;
	CORBA__LongDouble	other;
	CORBA__LongDouble	RETVAL;

        self = SvLDV (ST(0));

        other = SvLDV (ST(1));
#line 751 "MICO.xs"
    RETVAL = self*other;
#line 1586 "MICO.c"
	ST(0) = ld_from_longdouble (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__LongDouble_neg)
{
    dXSARGS;
    if (items < 1 || items > 3)
	croak("Usage: CORBA::LongDouble::neg(self, other=0, reverse=&sv_undef)");
    {
	CORBA__LongDouble	self;
	CORBA__LongDouble	RETVAL;

        self = SvLDV (ST(0));
#line 759 "MICO.xs"
    RETVAL = -self;
#line 1605 "MICO.c"
	ST(0) = ld_from_longdouble (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__LongDouble_abs)
{
    dXSARGS;
    if (items < 1 || items > 3)
	croak("Usage: CORBA::LongDouble::abs(self, other=0, reverse=&sv_undef)");
    {
	CORBA__LongDouble	self;
	CORBA__LongDouble	RETVAL;

        self = SvLDV (ST(0));
#line 767 "MICO.xs"
    RETVAL = (self > 0) ? self : -self;
#line 1624 "MICO.c"
	ST(0) = ld_from_longdouble (RETVAL);
	if (SvREFCNT(ST(0))) sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_CORBA__LongDouble_cmp)
{
    dXSARGS;
    if (items < 2 || items > 3)
	croak("Usage: CORBA::LongDouble::cmp(self, other, reverse=&sv_undef)");
    {
	CORBA__LongDouble	self;
	CORBA__LongDouble	other;
	SV *	reverse;
	int	RETVAL;

        self = SvLDV (ST(0));

        other = SvLDV (ST(1));

	if (items < 3)
	    reverse = &sv_undef;
	else {
	    reverse = ST(2);
	}
#line 777 "MICO.xs"
    if (SvTRUE (reverse))
      RETVAL = (self == other) ? 0 : ((self > other) ? 1 : -1);
    else
      RETVAL = (other == self) ? 0 : ((other > self) ? 1 : -1);
#line 1656 "MICO.c"
	ST(0) = sv_newmortal();
	sv_setiv(ST(0), (IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_CORBA__MICO__InstVars_DESTROY)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::MICO::InstVars::DESTROY(self)");
    {
	SV *	self = ST(0);
#line 790 "MICO.xs"
    pmico_instvars_destroy ((PMicoInstVars *)SvPVX(SvRV(self)));
#line 1672 "MICO.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_CORBA__Dispatcher_DESTROY)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::Dispatcher::DESTROY(self)");
    {
	CORBA__Dispatcher	self;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    self = (CORBA__Dispatcher) tmp;
	}
	else
	    croak("self is not a reference");
#line 798 "MICO.xs"
    if (self)
	delete self;
#line 1694 "MICO.c"
    }
    XSRETURN_EMPTY;
}

#ifdef HAVE_GTK
#define XSubPPtmpAAAA 1

XS(XS_CORBA__MICO__GtkDispatcher_new)
{
    dXSARGS;
    if (items != 1)
	croak("Usage: CORBA::MICO::GtkDispatcher::new(self)");
    {
	CORBA__MICO__GtkDispatcher	RETVAL;
#line 808 "MICO.xs"
    {
	GtkFunctions funcs;

	funcs.gtk_main_iteration = 
	  (gint (*) (void))get_c_func ("gtk_main_iteration");
	funcs.gtk_timeout_add = 
	  (guint (*) (guint32, GtkFunction, gpointer))
	     get_c_func ("gtk_timeout_add");
	funcs.gtk_timeout_remove = 
	  (void (*) (guint))get_c_func ("gtk_timeout_remove");
	funcs.gdk_input_add = 
	  (gint (*) (gint, GdkInputCondition, GdkInputFunction, gpointer))
	     get_c_func ("gdk_input_add");
	funcs.gdk_input_remove = 
	  (void (*) (gint)) get_c_func ("gdk_input_remove");

	RETVAL = new GtkDispatcher (&funcs);
    }
#line 1728 "MICO.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "CORBA::MICO::GtkDispatcher", (void*)RETVAL);
    }
    XSRETURN(1);
}

#endif /* HAVE_GTK */
#ifdef __cplusplus
extern "C"
#endif
XS(boot_CORBA__MICO)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("CORBA::MICO::load_interface", XS_CORBA__MICO_load_interface, file);
        newXS("CORBA::ORB_init", XS_CORBA_ORB_init, file);
        newXS("CORBA::Any::new", XS_CORBA__Any_new, file);
        newXS("CORBA::Any::value", XS_CORBA__Any_value, file);
        newXS("CORBA::Any::type", XS_CORBA__Any_type, file);
        newXS("CORBA::Any::DESTROY", XS_CORBA__Any_DESTROY, file);
        newXS("CORBA::BOA::impl_is_ready", XS_CORBA__BOA_impl_is_ready, file);
        newXS("CORBA::BOA::deactivate_impl", XS_CORBA__BOA_deactivate_impl, file);
        newXS("CORBA::BOA::obj_is_ready", XS_CORBA__BOA_obj_is_ready, file);
        newXS("CORBA::BOA::deactivate_obj", XS_CORBA__BOA_deactivate_obj, file);
        newXS("CORBA::BOA::dispose", XS_CORBA__BOA_dispose, file);
        newXS("CORBA::BOA::DESTROY", XS_CORBA__BOA_DESTROY, file);
        newXS("CORBA::ORB::BOA_init", XS_CORBA__ORB_BOA_init, file);
        newXS("CORBA::ORB::dispatcher", XS_CORBA__ORB_dispatcher, file);
        newXS("CORBA::ORB::object_to_string", XS_CORBA__ORB_object_to_string, file);
        newXS("CORBA::ORB::resolve_initial_references", XS_CORBA__ORB_resolve_initial_references, file);
        newXS("CORBA::ORB::string_to_object", XS_CORBA__ORB_string_to_object, file);
        newXS("CORBA::ORB::bind", XS_CORBA__ORB_bind, file);
        newXS("CORBA::ORB::preload", XS_CORBA__ORB_preload, file);
        newXS("CORBA::ORB::DESTROY", XS_CORBA__ORB_DESTROY, file);
        newXS("CORBA::ORB::run", XS_CORBA__ORB_run, file);
        newXS("CORBA::ORB::shutdown", XS_CORBA__ORB_shutdown, file);
        newXS("CORBA::ORB::perform_work", XS_CORBA__ORB_perform_work, file);
        newXS("CORBA::ORB::work_pending", XS_CORBA__ORB_work_pending, file);
        newXS("CORBA::Object::_get_interface", XS_CORBA__Object__get_interface, file);
        newXS("CORBA::Object::_get_implementation", XS_CORBA__Object__get_implementation, file);
        newXS("CORBA::Object::_repoid", XS_CORBA__Object__repoid, file);
        newXS("CORBA::Object::_ident", XS_CORBA__Object__ident, file);
        newXS("CORBA::Object::_set_repoid", XS_CORBA__Object__set_repoid, file);
        newXS("CORBA::Object::_boa", XS_CORBA__Object__boa, file);
        newXS("CORBA::Object::_self", XS_CORBA__Object__self, file);
        newXS("CORBA::Object::_restore", XS_CORBA__Object__restore, file);
        newXS("CORBA::TypeCode::new", XS_CORBA__TypeCode_new, file);
        newXS("CORBA::TypeCode::DESTROY", XS_CORBA__TypeCode_DESTROY, file);
        newXS("CORBA::BOAObjectRestorer::new", XS_CORBA__BOAObjectRestorer_new, file);
        newXS("CORBA::BOAObjectRestorer::add_binders", XS_CORBA__BOAObjectRestorer_add_binders, file);
        newXS("CORBA::BOAObjectRestorer::add_restorers", XS_CORBA__BOAObjectRestorer_add_restorers, file);
        newXS("CORBA::LongLong::new", XS_CORBA__LongLong_new, file);
        newXS("CORBA::LongLong::stringify", XS_CORBA__LongLong_stringify, file);
        newXS("CORBA::LongLong::add", XS_CORBA__LongLong_add, file);
        newXS("CORBA::LongLong::subtract", XS_CORBA__LongLong_subtract, file);
        newXS("CORBA::LongLong::div", XS_CORBA__LongLong_div, file);
        newXS("CORBA::LongLong::mul", XS_CORBA__LongLong_mul, file);
        newXS("CORBA::LongLong::mod", XS_CORBA__LongLong_mod, file);
        newXS("CORBA::LongLong::neg", XS_CORBA__LongLong_neg, file);
        newXS("CORBA::LongLong::abs", XS_CORBA__LongLong_abs, file);
        newXS("CORBA::LongLong::cmp", XS_CORBA__LongLong_cmp, file);
        newXS("CORBA::ULongLong::new", XS_CORBA__ULongLong_new, file);
        newXS("CORBA::ULongLong::stringify", XS_CORBA__ULongLong_stringify, file);
        newXS("CORBA::ULongLong::add", XS_CORBA__ULongLong_add, file);
        newXS("CORBA::ULongLong::subtract", XS_CORBA__ULongLong_subtract, file);
        newXS("CORBA::ULongLong::div", XS_CORBA__ULongLong_div, file);
        newXS("CORBA::ULongLong::mul", XS_CORBA__ULongLong_mul, file);
        newXS("CORBA::ULongLong::mod", XS_CORBA__ULongLong_mod, file);
        newXS("CORBA::ULongLong::cmp", XS_CORBA__ULongLong_cmp, file);
        newXS("CORBA::LongDouble::new", XS_CORBA__LongDouble_new, file);
        newXS("CORBA::LongDouble::stringify", XS_CORBA__LongDouble_stringify, file);
        newXS("CORBA::LongDouble::add", XS_CORBA__LongDouble_add, file);
        newXS("CORBA::LongDouble::subtract", XS_CORBA__LongDouble_subtract, file);
        newXS("CORBA::LongDouble::div", XS_CORBA__LongDouble_div, file);
        newXS("CORBA::LongDouble::mul", XS_CORBA__LongDouble_mul, file);
        newXS("CORBA::LongDouble::neg", XS_CORBA__LongDouble_neg, file);
        newXS("CORBA::LongDouble::abs", XS_CORBA__LongDouble_abs, file);
        newXS("CORBA::LongDouble::cmp", XS_CORBA__LongDouble_cmp, file);
        newXS("CORBA::MICO::InstVars::DESTROY", XS_CORBA__MICO__InstVars_DESTROY, file);
        newXS("CORBA::Dispatcher::DESTROY", XS_CORBA__Dispatcher_DESTROY, file);
#if XSubPPtmpAAAA
        newXS("CORBA::MICO::GtkDispatcher::new", XS_CORBA__MICO__GtkDispatcher_new, file);
#endif

    /* Initialisation Section */

#if XSubPPtmpAAAA
#endif
#line 833 "MICO.xs"
    pmico_init_exceptions();
    pmico_init_typecodes();

#line 1824 "MICO.c"

    /* End of Initialisation Section */

    ST(0) = &sv_yes;
    XSRETURN(1);
}
